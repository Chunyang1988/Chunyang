{
  "name": "Chunyang",
  "tagline": "",
  "body": "##Android常用库\r\n\r\n\r\n网络：\r\n\r\na.Square出品\r\n\r\n1.[retrofit](http://square.github.io/retrofit/)\r\n\r\n2.[OkHttp](http://square.github.io/okhttp/)\r\n\r\n\r\n异步：\r\n\r\n1.[RxAndroid](https://github.com/ReactiveX/RxAndroid)|[RxJava](https://github.com/ReactiveX/RxJava)\r\n\r\n2.Rx**例如RxPermissions、RxBinding\r\n\r\n\r\n通信：\r\n\r\n1.如果你用RxJava建议直接使用[RxBus](https://github.com/Chunyang1988cn/Chunyang/wiki/RxBus)(不能算作库，只有简单几行代码）\r\n\r\n2.[EventBus](https://github.com/greenrobot/EventBus)\r\n\r\n3.[Otto](http://square.github.io/otto/)\r\n\r\n\r\n# 观察者模式\r\n\r\n\r\n## 基本讲解\r\n\r\n观察者模式简单说就是“发布”--“订阅”--“通知”--“更新”一种交互形式，是一种一对多的依赖关系，即一个“发布者”，可以有多个“订阅者”接受与更新数据。\r\n\r\n\r\n\r\n### 案例讲解\r\n\r\n按照当下流行公众号来讲解，例如你关注了一个公众号“微信运动”，他就提供发布信息的作用，也就是“发布者”，而我们关注的人，也就是“订阅者”，当“微信运动”发布消息的时候，我们所有关注人，都会收到消息，也就是“通知”“订阅者”，而我们收到信息后，进行了“更新”。\r\n\r\n\r\n\r\n# RxJava\r\n\r\n\r\n## 基础\r\n\r\nRxJava究竟是什么呢，其实说简单的就是处理异步的，但是又很灵活，后续讲解就会明白了，他是一种观察者模式的异步处理，一说到观察者模式就会用到Observable、Subscriber。\r\n\r\nObservable发送消息，而Subscriber则用于消费消息。\r\n\r\n上文讲解的观察者模式，就说到了“发布”--“订阅”--“通知”--“更新”，你就可以理解Observable是用户“发布”消息的，而Subscriber用户“通知”消息的。\r\n\r\n## 讲解\r\n\r\n### 1.创建Observable\r\n\r\n准备发布消息\r\n\r\n        Observable.create(new Observable.OnSubscribe<String>() {\r\n\r\n            @Override\r\n            public void call(Subscriber<? super String> subscriber) {\r\n                subscriber.onNext(\"onNext1\");\r\n                subscriber.onNext(\"onNext2\");\r\n                subscriber.onCompleted();\r\n            }\r\n        });\r\n\r\n上面代码就是基本的创建方法，而Observable还提供了几个常用方式，例如：\r\n\r\n        Observable.just(\"onNext1\", \"onNext2\");\r\n与\r\n\r\n        Observable.from(new String[]{\"onNext1\", \"onNext2\"});\r\n\r\n上面代码都是一个效果，返回都是Observable<String>\r\n\r\n\r\n\r\n### 2.订阅Subscribe \r\n\r\n这里面就可以理解成上文所说的关注公众号的例子，发生订阅关系\r\n\r\n        observables.subscribe(Subscriber|Observer);\r\n\r\n\r\n### 3.Subscriber与Observer创建与区别\r\n\r\nSubscriber与Observer基本没有区别，Subscriber其实就是实现Observer的抽象类。\r\n\r\n### 主要区别在与：\r\n\r\n1.onStart():\r\n\r\n这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作\r\n\r\n2.unsubscribe(): \r\n\r\n这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。\r\n\r\n\r\n### 4.线程调度器\r\n\r\n\r\n\t  Observable.create(new Observable.OnSubscribe<String>() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void call(Subscriber<? super String> subscriber) {\r\n\t\t\t\t\tLog.e(\"TAG\", Thread.currentThread().getName() + \" call \"\r\n\t\t\t\t\t\t\t+ Thread.currentThread().getId());\r\n\t\t\t\t\tsubscriber.onNext(\"onNext1、onNext2、onNext3,onNext4、onNext5、onNext6,onNext7、onNext8、onNext9\");\r\n\t\t\t\t\tsubscriber.onCompleted();\r\n\t\t\t\t}\r\n\t\t\t}).subscribeOn(Schedulers.computation())\r\n\t\t\t\t\t.doOnSubscribe(new Action0() {\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void call() {\r\n\t\t\t\t\t\t\tLog.e(\"TAG\", Thread.currentThread().getName()\r\n\t\t\t\t\t\t\t\t\t+ \" doOnSubscribe \"\r\n\t\t\t\t\t\t\t\t\t+ Thread.currentThread().getId());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.subscribeOn(AndroidSchedulers.mainThread())\r\n\t\t\t\t\t.observeOn(Schedulers.io())\r\n\t\t\t\t\t.flatMap(new Func1<String, Observable<String>>() {\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic Observable<String> call(String t) {\r\n\t\t\t\t\t\t\tLog.e(\"TAG\", Thread.currentThread().getName()\r\n\t\t\t\t\t\t\t\t\t+ \" flatMap1 \" + Thread.currentThread().getId());\r\n\t\t\t\t\t\t\treturn Observable.from(t.split(\",\"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.observeOn(Schedulers.newThread())\r\n\t\t\t\t\t.flatMap(new Func1<String, Observable<String>>() {\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic Observable<String> call(String t) {\r\n\t\t\t\t\t\t\tLog.e(\"TAG\", Thread.currentThread().getName()\r\n\t\t\t\t\t\t\t\t\t+ \" flatMap2 \" + Thread.currentThread().getId());\r\n\t\t\t\t\t\t\treturn Observable.from(t.split(\"、\"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}).observeOn(AndroidSchedulers.mainThread())\r\n\t\t\t\t\t.subscribe(new Subscriber<String>() {\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onCompleted() {\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onError(Throwable e) {\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onNext(String s) {\r\n\t\t\t\t\t\t\tLog.e(\"TAG\", s + \" \" + Thread.currentThread().getName()\r\n\t\t\t\t\t\t\t\t\t+ \" onNext \" + Thread.currentThread().getId());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\r\nsubscribeOn(): \r\n\r\n指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 \r\n\r\nobserveOn():\r\n\r\n指定 Subscriber 所运行在的线程。或者叫做事件消费的线程\r\n\r\n其实可以理解成observeOn(...) 指定的是它之后的操作所在的线程 Observable 所对应的  Subscriber ，而subscribeOn(...)指定的是Observable （被观察者）或者 OnSubscribe 当 Observable而注意doOnSubscribe也是遵循上面规律，但是doOnSubscribe会首先执行。\r\n\r\n\r\n\r\n# RxBus\r\n\r\n## 基本使用\r\n\r\n### A、注册\r\n一般使用都向Android广播使用一样，在onCreate或者onResume注册\r\n\r\n        rxBusString = RxBus.getDefault().toObserverable(String.class).subscribe(new Subscriber<String>() {\r\n            @Override\r\n            public void onCompleted() {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onNext(String s) {\r\n                mContent.setText(s);\r\n            }\r\n        });\r\n\r\n### B、解绑\r\n\r\n在onDestroy或者onPause中取消，防止内存泄漏等问题\r\n\r\n        if (!rxBusString.isUnsubscribed())\r\n            rxBusString.unsubscribe();\r\n\r\n\r\n\r\n### C、发送请求\r\n\r\npost中参数是object类型，也就是你注册时候toObserverable()中的类型，只要是符合这种类型（可以理解成符合广播的Action),后注册这个“广播”的都会收到。\r\n\r\nPS：其实说广播是方便大家理解，真正的按照观察者模式应该理解成，“发布”给所有符合条件的“订阅者”。\r\n\r\n\t  RxBus.getDefault().post(\"this post is from Activity\");\r\n\r\n\r\n\r\n\r\n###  D、结束\r\n\r\nRxBus不是库，只是如下几行代码而已\r\n\r\n\r\n\r\n\tpublic class RxBus {\r\n\t\tprivate static volatile RxBus defaultInstance;\r\n\t\t// 主题\r\n\t\tprivate final Subject bus;\r\n\r\n\t\t// PublishSubject只会把在订阅发生的时间点之后来自原始Observable的数据发射给观察者\r\n\t\tpublic RxBus() {\r\n\t\t\tbus = new SerializedSubject<>(PublishSubject.create());\r\n\t\t}\r\n\r\n\t\t// 单例RxBus\r\n\t\tpublic static RxBus getDefault() {\r\n\t\t\tRxBus rxBus = defaultInstance;\r\n\t\t\tif (defaultInstance == null) {\r\n\t\t\t\tsynchronized (RxBus.class) {\r\n\t\t\t\t\trxBus = defaultInstance;\r\n\t\t\t\t\tif (defaultInstance == null) {\r\n\t\t\t\t\t\trxBus = new RxBus();\r\n\t\t\t\t\t\tdefaultInstance = rxBus;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn rxBus;\r\n\t\t}\r\n\r\n\t\t// 提供了一个新的事件\r\n\t\tpublic void post(Object o) {\r\n\t\t\tbus.onNext(o);\r\n\t\t}\r\n\r\n\t\t// 根据传递的 eventType 类型返回特定类型(eventType)的 被观察者\r\n\t\tpublic <T> Observable<T> toObserverable(Class<T> eventType) {\r\n\t\t\treturn bus.ofType(eventType).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());\r\n\t//        这里感谢小鄧子的提醒: ofType = filter + cast\r\n\t//        return bus.filter(new Func1<Object, Boolean>() {\r\n\t//            @Override\r\n\t//            public Boolean call(Object o) {\r\n\t//                return eventType.isInstance(o);\r\n\t//            }\r\n\t//        }) .cast(eventType);\r\n\t\t}\r\n\r\n\r\n\t\tpublic <T> Observable<T> toObserverable(Class<T> eventType, Scheduler scheduler, Scheduler observe) {\r\n\t\t\treturn bus.ofType(eventType).subscribeOn(scheduler).observeOn(observe);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n# SQLBrite\r\n\r\n\r\n[SQLBrite](https://github.com/square/sqlbrite)e说简单点就是通过RxJava方式写的一种数据库模式，因为数据库操作最好是不要再Android主线程操作的，因此，使用RxJava方式能够很方便的调度线程。\r\n\r\n## 基本使用\r\n\r\n### A.创建\r\n\r\n        SqlBrite sqlBrite = SqlBrite.create();\r\n        BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());\r\n\r\n\r\n### B.使用\r\n\r\n  a).insert、delete、update\r\n\r\n  跟SQLiteDatabase.insert | SQLiteDatabase.update | BriteDatabase.delete的方式是一样使用。\r\n\r\n        BriteDatabase.insert(@NonNull String table, @NonNull ContentValues values)\r\n\r\n        BriteDatabase.update(@NonNull String table, @NonNull ContentValues values,\r\n                      @Nullable String whereClause, @Nullable String... whereArgs) \r\n\r\n        BriteDatabase.delete(@NonNull String table, @Nullable String whereClause,\r\n                      @Nullable String... whereArgs) \r\n\r\n\r\n\r\n  b). createQuery\r\n\r\n  跟SQLiteDatabase.rawQuery类此，只是返回类型不同返回QueryObservable\r\n\r\n\r\n       BriteDatabase.createQuery(@NonNull final String table, @NonNull String sql)\r\n\r\n       BriteDatabase.createQuery(@NonNull final String table, @NonNull String sql,\r\n                                       @NonNull String... args)\r\n\r\n\r\n  PS:\r\n  之后就是更使用RxJava方式交互\r\n\r\n\r\n  d).事物Transaction newTransaction() \r\n\r\n  简单事例\r\n\r\n\r\n    public void setCacheList(List<Cache> lists) {\r\n        BriteDatabase.Transaction transction = dbHelper.newTransaction();\r\n        try {\r\n            for (Cache cache : lists) {\r\n                ContentValues values = new ContentValues();\r\n                cache.setContentValues(values);\r\n                dbHelper.insert(CacheColumn.TABLE_NAME, values);\r\n                transction.markSuccessful();\r\n            }\r\n        } finally {\r\n            transction.end();\r\n        }\r\n    }\r\n\r\n\r\n\r\n### C.简单使用\r\n\r\n    public void addCache(String json, int type) {\r\n        Cache cache = new Cache();\r\n        cache.setType(type);\r\n        cache.setJson(json);\r\n        final ContentValues cv = new ContentValues();\r\n        cache.setContentValues(cv);\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"select \").append(CacheColumn.JSON).append(\" from \").append(CacheColumn.TABLE_NAME);\r\n        Observable<SqlBrite.Query> query = dbHelper.createQuery(CacheColumn.TABLE_NAME, sb.toString());\r\n        query.map(new HaveDataFunc()).subscribe(new Action1<Boolean>() {\r\n            @Override\r\n            public void call(Boolean aBoolean) {\r\n                if (aBoolean)\r\n                    dbHelper.update(CacheColumn.TABLE_NAME, cv, CacheColumn.TYPE + \" =?\", \"1\");\r\n                else\r\n                    dbHelper.insert(CacheColumn.TABLE_NAME, cv);\r\n\r\n                dbHelper.update(CacheColumn.TABLE_NAME, cv, CacheColumn.TYPE + \" =?\", \"1\");\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n    static class HaveDataFunc implements Func1<SqlBrite.Query, Boolean> {\r\n\r\n        @Override\r\n        public Boolean call(SqlBrite.Query query) {\r\n            Cursor cursor = query.run();\r\n            return cursor != null && cursor.moveToNext();\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    public void getCache(int type, Subscriber<List<Cache>> subscriber) {\r\n        Observable<SqlBrite.Query> query = dbHelper.createQuery(CacheColumn.TABLE_NAME, \"select * from \" + CacheColumn.TABLE_NAME);\r\n        query.map(new Func1<SqlBrite.Query, List<Cache>>() {\r\n            @Override\r\n            public List<Cache> call(SqlBrite.Query query) {\r\n                List<Cache> list = null;\r\n                Cursor cursor = query.run();\r\n                if (cursor != null) {\r\n                    list = new ArrayList<Cache>();\r\n                    while (cursor.moveToNext()) {\r\n                        Cache r = new Cache();\r\n                        r.setDataFromCursor(cursor);\r\n                        list.add(r);\r\n                    }\r\n                }\r\n                return list;\r\n            }\r\n        }).observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber);\r\n    }\r\n\r\n\r\n\r\n# EventBus\r\n\r\n## 基本使用\r\n\r\n### A、注册\r\n同RxBus一样在onCreate或者onResume注册\r\n\r\n    EventBus.getDefault().register(this);\r\n\r\n\r\n### B、解绑\r\n\r\n在onDestroy或者onPause中取消，防止内存泄漏等问题\r\n\r\n    EventBus.getDefault().unregister(this);\r\n\r\n### C、发送请求\r\n\r\n    EventBus.getDefault().post(\"this post is from Activity\");\r\n\r\n### D、数据接收\r\n\r\n    @Subscribe(threadMode = ThreadMode.MainThread)\r\n    public void onEvent(String mess) {\r\n        mContent.setText(mess);\r\n    }\r\n\r\n### PS:\r\n\r\n@Subscribe就是“订阅者”\r\n\r\n上面的Post类型为Object，而@Subscribe中的方法类型是与其相对应才能接收到\r\n\r\n\r\n也就是说上文post了，在符合相应类型的@Subscribe中都能够接受到消息。\r\n\r\n\r\n### 理解\r\n\r\n观察者模式主要是讲的发布者与订阅者关系\r\n\r\npost(Object object)就是发布信息人，而@Subscribe则是订阅者，接受信息的人。\r\n\r\n在观察者模式中，订阅者有可能是多人订阅，以此只要@Subscribe中类型与post(Object object)相同，即可收到信息\r\n\r\n更好的理解就是广播\r\n\r\n只要注册了相应Action的广播，收到这个Action，所有注册的都能够收到。\r\n\r\n\r\n\r\n# 源码解析\r\n\r\n\r\n[EventBus 3.0 源码分析](http://www.jianshu.com/p/f057c460c77e)  |  作者  [Skykai521](https://github.com/Skykai521)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}