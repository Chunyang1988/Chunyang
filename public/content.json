{"meta":{"title":"Chunyang1988","subtitle":null,"description":null,"author":"Chunyang1988","url":"https://chunyang1988.github.io"},"pages":[{"title":"关于","date":"2017-08-03T15:04:14.000Z","updated":"2017-08-03T15:04:14.000Z","comments":false,"path":"about/index.html","permalink":"https://chunyang1988.github.io/about/index.html","excerpt":"","text":"chunyang1988，一个98年出生的小伙 只是想弄一个博客，写写日记，写写技术而已让自己有件事情做，不停的思考与进步没有太多功底，一步一步开始学习不想说太多，希望能够进步一切皆有可能相信自己"}],"posts":[{"title":"Mac 终端常用命令","slug":"mac-command","date":"2018-01-12T08:37:17.000Z","updated":"2018-03-20T08:38:40.424Z","comments":true,"path":"2018/01/12/mac-command/","link":"","permalink":"https://chunyang1988.github.io/2018/01/12/mac-command/","excerpt":"","text":"列出文件 1234ls 参数 目录名# 例如ls Documents 参数：-w 显示中文-l 详细信息-a 显示全部包含隐藏文件 显示目录路径 123pwd# 结果/Users/xx/Documents 转换目录 123cd 目录名# 例如cd Documents 创建新目录 123mkdir 目录名# 例如mkdir newDir 删除目录 123rmdir 目录名# 例如rmdir newDir 拷贝文件 1234cp 参数 源文件 目标文件# 例如cp Download/a.txt Documents/a.txtcp Download/a.txt Documents 删除文件 123rm 参数 文件# 例如rm -rf Documents/a.txt 参数-f 强制删除 移动文件 12345mv 文件# 移动文件并以原名移动mv Download/a.txt Documents# 移动并以新名存储mv Download/a.txt Documents/b.txt 查看文件 123cat 文件名# 例如cat t.txt 显示文件类型 123file 文件名# 例如file t.txt 查找文件 123find path -name &quot;xx&quot;# 例如 查找当前目录后缀为.txt 的文件find . -name &quot;*.txt&quot; 时间相关 12date 显示系统当前日期和时间cal 显示日历 File 隐藏文件显示/隐藏 123456# 显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true# 恢复隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false # 关闭所有 Finderkillall Finder","categories":[],"tags":[{"name":"Shell 、Mac","slug":"Shell-、Mac","permalink":"https://chunyang1988.github.io/tags/Shell-、Mac/"}]},{"title":"Android 动态授权那些事","slug":"Android-Permission","date":"2017-12-31T06:34:23.000Z","updated":"2018-03-20T06:36:00.504Z","comments":true,"path":"2017/12/31/Android-Permission/","link":"","permalink":"https://chunyang1988.github.io/2017/12/31/Android-Permission/","excerpt":"","text":"关键字 动态授权 Android API 学习目标了解动态授权机制，以及各个版本注意事项。文章结尾有项目地址。 正文从 Android 6.0(API 23)开始，应用要使用危险全系时候，需要动态获取权限，而不是安装时候授权。 系统权限分为两类：正常权限和危险权限 正常权限不会直接给用户隐私带来风险。如果在应用的AndroidManifes中注册，系统将会自动授予权限。 危险权限会授予应用访问用户机密数据的权限，如果在应用的AndroidManifes中注册，则用户必须明确批准应用才能使用此权限。 运行时权限说明： 如果设备运行在 Android5.1 或者更低版本，如果 AndroidManifest 列出危险权限，则用户必须安装应用时授予此权限，反之则无法安装应用。 如果设备运行在 Android6.0 或者更高版本，应用必须在 AndroidManifest 中列出权限，并且它必须在运行时请求需要的危险权限。 流程 检测权限如果使用到危险权限，则每次执行需要这一权限的操作时，必须都要检查是否已有权限。检测权限需要调用PermissionChecker.checkSelfPermission(@NonNull Context context,@NonNull String permission)方法例如： 12int permissionCheck = PermissionChecker.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR); 如果有此权限，方法返回PackageManager.PERMISSION_GRANTED，反之返回PackageManager.PERMISSION_DENIED 请求权限如果应用无所需的权限，则应用必须调用ActivityCompat.requestPermissions(final @NonNull Activity activity,final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode)方法来请求适当的权限。这时候会跳出系统对话框（不可定制），询问用户是否授权，系统会将结果会调给Activity.onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)方法。 例如： 1234567891011121314151617181920212223242526// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don&apos;t block // this thread waiting for the user&apos;s response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; 注：ActivityCompat.shouldShowRequestPermissionRationale()一般用它来判断，如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 Don’t ask again 选项，此方法将返回 false。如果设备规范禁止应用具有该权限，此方法也会返回 false。因此用此方法用于解释应用为什么需要权限的情况，来提示用户权限使用。 处理权限请求当应用请求权限后，系统会将结果会调给onRequestPermissionsResult()方法例如： 123456789101112131415161718192021222324@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other &apos;case&apos; lines to check for other // permissions this app might request &#125;&#125; 请求的权限结果会返回给此方法，其中int[] grantResults用户判断当时请求的权限String permissions[]结果，如果获取到权限则为PackageManager.PERMISSION_GRANTED其他都未未获取到权限。 详情请看Android-Permission","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Android Gradle 基础说明","slug":"Android-Gradle-Basic-Instructions","date":"2017-12-24T07:34:01.000Z","updated":"2018-03-20T06:37:49.023Z","comments":true,"path":"2017/12/24/Android-Gradle-Basic-Instructions/","link":"","permalink":"https://chunyang1988.github.io/2017/12/24/Android-Gradle-Basic-Instructions/","excerpt":"","text":"Android Studio 目录结构Android Studio 目录结构说明： 123456789101112131415161718├── app #Android App目录│ ├── app.iml│ ├── build #构建输出目录│ ├── build.gradle #构建脚本│ ├── libs #so相关库│ ├── proguard-rules.pro #proguard混淆配置│ └── src #源代码，资源等├── build│ └── intermediates├── build.gradle #工程构建文件├── gradle│ └── wrapper├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat├── LibSqlite.iml├── local.properties #配置Androod SDK位置文件└── settings.gradle #工程配置 说明 settings.gradle：用于配置 Project 中有几个 Module build.gradle: Projcet 目录设置为整个项目所使用的配置； Module 目录当前项目所使用的配置； AndroidMainfest 占位符在项目使用时候，可能或多或少会需要在 AndroidMainfest 里面配置一些特殊数据，例如友盟的渠道，第三方的 ApkKey 等信息，如： 12345# 腾讯 APPID&lt;data android:scheme=&quot;tencent$&#123;TENCENT_KEY&#125;&quot; /&gt;# 友盟渠道&lt;meta-data android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; android:name=&quot;UMENG_CHANNEL&quot;/&gt; 上面的 ${TENCENT_KEY} 或 ${UMENG_CHANNEL_VALUE} 就是占位符，我们替换的时候使用 manifestPlaceholders = [UMENG_CHANNEL_VALUE: &#39;tencent&#39;] 或manifestPlaceholders.put(&quot;UMENG_CHANNEL_VALUE&quot;,&#39;tencent&#39;) 123manifestPlaceholders = [UMENG_CHANNEL_VALUE: &apos;tencent&apos;]manifestPlaceholders.put(&quot;UMENG_CHANNEL_VALUE&quot;,&apos;tencent&apos;) 具体放在哪里使用manifestPlaceholders可以根据实际需求例如放入buildTypes、defaultConfig、productFlavors等等地方 自定义 BuildConfigBuildConfig.java是 Android Gradle自动编译生成的一个文件，我们也可以通过buildConfigField来自定义一些属性。 123456# String 类型buildConfigField &quot;String&quot;, &quot;TENCENT_KEY&quot;, &apos;&quot;Value&quot;&apos;# boolean 类型 buildConfigField &quot;boolean&quot;, &quot;CONFIG&quot;, &quot;true&quot;# int 类型 buildConfigField &quot;int&quot;, &quot;VALUE&quot;, &quot;1&quot; 这样BuildConfig.java就会有上面那自定义的属性 1234// Fields from default config.public static final boolean CONFIG = true;public static final String TENCENT_KEY = &quot;Value&quot;;public static final int VALUE = 1; 具体放在哪里使用，可以根据实际需求例如放入buildTypes、defaultConfig、productFlavors等等地方 统一依赖管理统一依赖的目的是方便各个 Module 中引用版本升级时候防止多个 Module 改变而只需要更改这一个文件即可。 创建一个config.gradle文件 1234567891011ext &#123; android = [compileSdkVersion: 26, minSdkVersion : 15, targetSdkVersion : 26 ] dependencies = [ &quot;appcompat-v7&quot;: &apos;com.android.support:appcompat-v7:26.1.0&apos; ]&#125; 在 Project 项目 build.gradle 中引用 1apply from: &quot;config.gradle&quot; 接下来只需要在使用的 build.gradle 中引用即可。 123456789101112131415161718192021222324android &#123; compileSdkVersion rootProject.ext.android.compileSdkVersion defaultConfig &#123; minSdkVersion rootProject.ext.android.minSdkVersion targetSdkVersion rootProject.ext.android.targetSdkVersion applicationId &quot;com.xiu8.apidemo&quot; versionCode 1 versionName &quot;1.0&quot; buildConfigField &quot;String&quot;, &quot;TENCENT_KEY&quot;, &apos;&quot;Value&quot;&apos; buildConfigField &quot;boolean&quot;, &quot;CONFIG&quot;, &quot;true&quot; buildConfigField &quot;int&quot;, &quot;VALUE&quot;, &quot;1&quot; &#125; ... &#125;dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile rootProject.ext.dependencies[&quot;appcompat-v7&quot;]&#125; 这样即可解决统一依赖管理，方便你随意升级版版本，而不用那个改其他 Module","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://chunyang1988.github.io/tags/Gradle/"}]},{"title":"Docker 安装 Nexus3 实例","slug":"Docker-Nexus3","date":"2017-12-15T04:41:26.000Z","updated":"2018-03-07T04:54:47.834Z","comments":true,"path":"2017/12/15/Docker-Nexus3/","link":"","permalink":"https://chunyang1988.github.io/2017/12/15/Docker-Nexus3/","excerpt":"","text":"运行运行 Nexus3 时候一般会暴露出指定端口绑定到主机； 1docker run -d -p 8081:8081 --name nexus sonatype/nexus3 测试： 123456# 浏览器中访问地址localhost:8081# curl 检测地址curl -u admin:admin123 http://localhost:8081/service/metrics/ping 说明 默认凭证是： admin/admin123 持久数据推荐方法： 12 $ docker volume create --name nexus-data$ docker run -d -p 8081:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3 搭建私服浏览器中输入localhost:8081 进入 Nexus 平台 登录系统 输入用户名与密码 admin/admin123 创新私有库 按照步骤操作 第三部后选择 docker(hosted) 填写 name 按照下图创建 最后点击 Create repository 使用如何使用可以看我之前文章 上传库到私服","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chunyang1988.github.io/tags/Docker/"}]},{"title":"Docker 入门介绍","slug":"Docker-Introduction","date":"2017-12-03T04:38:26.000Z","updated":"2018-03-07T04:40:46.160Z","comments":true,"path":"2017/12/03/Docker-Introduction/","link":"","permalink":"https://chunyang1988.github.io/2017/12/03/Docker-Introduction/","excerpt":"","text":"Image 镜像Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数。 Docker 把应用程序及其依赖，打包在 image 文件里面。 Image 镜像文件是通用的，可以跨机器使用，为了方便共享，image 文件制作完成后，可以上传到仓库中。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。 基础指令12345678# 列出本机所有的 image 镜像文件docker image ls # 删除 image 镜像文件docker iange rm [imageName]# 获取镜像docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 获取镜像1docker image pull library/hello-world library是 image 文件所在的组，而Docker Hub 官网的默认组即library因此可以不写； hello-world 则是镜像名称； 查询镜像获取成功后，就可以查看这个 image 镜像 1docker image ls 删除镜像那么如何删除不用的镜像呢？ 1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 container 容器容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。 启动容器1docker container run hello-world docker container run 命令会从 image 文件中生成一个正在运行的容器实例； docker container run 命令会自动抓取 image 镜像中的功能，如果发现本地没有指定的 image 则会自动去仓库中拉取，因此 docker image pull 并不是必需命令； 查询容器image 文件生成的容器实例，本身也是一个文件，称为容器文件； 一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。 12345# 列出本机正在运行的容器docker container ls# 列出本机所有容器，包括终止容器docker container ls --all 终止容器1docker container stop [containerId] 删除容器文件上文说了启动容器会生成一个容器文件，现在将删除这个文件。 1docker container rm [containerID] 总结具体的某个镜像如何使用，其实看 Docker Hub 里面说明已经讲解很明了，例如 nexus3","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chunyang1988.github.io/tags/Docker/"}]},{"title":"上传库到私服（Nexus）","slug":"nexus-upload","date":"2017-11-28T15:10:23.000Z","updated":"2018-03-07T10:25:01.249Z","comments":true,"path":"2017/11/28/nexus-upload/","link":"","permalink":"https://chunyang1988.github.io/2017/11/28/nexus-upload/","excerpt":"","text":"这里面主要介绍 Android Studio 通过 gradle 上传库到私有 Maven 服务器 Nexus 的配置文件如何配置。简单的介绍一些基础知识，详细的可以看文章结尾处的链接。 关键字 Nexus Gradle Maven 学习目标 记录Nexus库的基础上传方式 理解基本定义 正文Maven是什么？ Maven 是一个项目管理和构建自动化工具。 什么是构建工具？ 构建工具是将软件项目构建相关的过程自动化的工具。构建一个软件项目通常包含以下一个或多个过程： 生成源码（如果项目使用自动生成源码）；从源码生成项目文档；编译源码；将编译后的代码打包成JAR文件或者ZIP文件；将打包好的代码安装到服务器、仓库或者其它的地方； Nexus又是什么？ Nexus是一个基于maven的仓库管理的社区项目。 主要的使用场景就是可以在局域网搭建一个maven私服,用来部署第三方公共构件或者作为远程仓库在该局域网的一个代理。 先说明一下本文不会过多介绍名词解析，在这里主要是记录最基本的配置，防止博主忘记。 正文的正文首先在项目的根目录的 gradle.properties中配置如下信息： 123456789101112131415161718# 用户名USERNAME=admin# 密码PASSWORD=admin123# 仓库地址NEXUS_REPOSITORY_URL=http://localhost:32770/repository/chunyang1988/# 库的描述信息DESCRIPTION=dependences lib for Android# 格式aar、jar等PACKAGING=aar# 库的包名GROUP_ID=com.cy# 库的项目名称ARTIFACT_ID=artifactId# 库的名称NAME=name# 库的版本号VERSION=1.0.0 一般在根目录创建如下nexus_upload.gradle上传task 123456789101112131415161718192021222324252627282930313233343536373839apply plugin: &apos;maven&apos;task androidJavadocs(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) &#123; classifier = &apos;javadoc&apos; from androidJavadocs.destinationDir&#125;task androidSourcesJar(type: Jar) &#123; classifier = &apos;sources&apos; from android.sourceSets.main.java.srcDirs&#125;artifacts &#123; archives androidSourcesJar archives androidJavadocsJar&#125;uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: NEXUS_REPOSITORY_URL) &#123; authentication(userName: USERNAME, password: PASSWORD) &#125; pom.project &#123; name NAME version VERSION artifactId ARTIFACT_ID groupId GROUP_ID packaging PACKAGING description DESCRIPTION &#125; &#125; &#125;&#125; 也可以将nexus_upload.gradle上传到服务器中方便下载使用。 接下来就是使用了如下： 在项目 Project 的 build.gradle 中添加如下代码： 12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url NEXUS_REPOSITORY_URL &#125; &#125;&#125; 在需要上传的 Module 中 添加如下代码： 12345NAME = &apos;permision&apos;VERSION = &apos;1.0.1&apos;ARTIFACT_ID = &apos;permision&apos;apply from: &apos;../nexus_maven.gradle&apos;//或者apply from: &apos;http://xxx/nexus_maven.gradle&apos; 之后就是运行此task即可，可以点击 AndroidStudio 右侧的 Gradle 选中相应树双击即可，也可以运行 ./gradlew uploadArchivesG即可。 到此基本基本记录已经完毕，更加深入的了解可以查看如下文章。 http://ifeve.com/maven-1/https://www.sonatype.com/download-oss-sonatype","categories":[],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://chunyang1988.github.io/tags/Tools/"}]},{"title":"Fragment基础知识","slug":"Fragment-Base","date":"2017-11-19T09:54:34.000Z","updated":"2018-01-19T09:59:37.515Z","comments":true,"path":"2017/11/19/Fragment-Base/","link":"","permalink":"https://chunyang1988.github.io/2017/11/19/Fragment-Base/","excerpt":"","text":"Fragment不能独立存在，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。例如：当activity暂停时，它拥有的所有的Fragment们都暂停了，当activity销毁时，它拥有的所有Fragment们都被销毁。 此文章没有任何讲解，只是纯粹的代码文档，列举几种方法，忘记的时候方便查看巩固使用的。 方法一：在activity的layoutxml文件中声明fragment 1234567891011121314151617181920212223&lt;LinearLayoutxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:baselineAligned=&quot;false&quot;&gt; &lt;fragment android:id=&quot;@+id/titles&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;4&quot; class=&quot;cn.eoe.first.fragment.LeftFragment&quot;/&gt; &lt;fragment android:id=&quot;@+id/details&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; class=&quot;cn.eoe.first.fragment.RightFragment&quot;/&gt;&lt;/LinearLayout&gt;class= &quot;cn.eoe.first.fragment.LeftFragment&quot; 换成android:name=&quot;cn.eoe.first.fragment.LeftFragment&quot;也可以 方法二：在代码中添加fragment到一个ViewGroup1234567891011//先获得Fragment的管理 FragmentManager fragmentManager = getFragmentManager();//所有Fragment的事务都是通过FragmentTransaction来完成，在通过管理者获取事务对象 FragmentTransaction fragmentTransaction = fragmentManager .beginTransaction();//实例化要添加的Fragment MyFragment fragment = new MyFragment();//添加Fragment通过layout中的id，实例对象，还有tag标签 fragmentTransaction.add(R.id.fragment_container1, fragment,&quot;fragment&quot;); //提交 fragmentTransaction.commit(); 或者 1234FragmentTransaction tx =getSupportFragmentManager().beginTransaction();tx.replace(R.id.main, Fragment.instantiate(MyHomeSlidingActivity.**this**, &quot;com.joymis.audio.FragmentmyhomeInfo&quot;));tx.commit(); 其中 “com.joymis.audio.FragmentmyhomeInfo”的代码 1234567891011121314151617 public class FragmentmyhomeInfo extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.layout_myhome_fragment, container,**false**); return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); &#125;&#125; layout中的布局为 1234&lt;FrameLayout android:id=&quot;@+id/fragment_container1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 其他要管理fragment们，需使用FragmentManager，要获取它，需在activity中调用方法getFragmentManager()。你可以用FragmentManager来做以上事情：1使用方法findFragmentById()或findFragmentByTag()，获取activity中已存在的fragment们。2使用方法popBackStack()从activity的后退栈中弹出fragment们（这可以模拟后退键引发的动作）。3用方法addOnBackStackChangedListerner()注册一个侦听器以监视后退栈的变化。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Android各种SdkVersion理解","slug":"Android-SdkVersion","date":"2017-11-09T08:26:33.000Z","updated":"2018-01-19T08:30:14.698Z","comments":true,"path":"2017/11/09/Android-SdkVersion/","link":"","permalink":"https://chunyang1988.github.io/2017/11/09/Android-SdkVersion/","excerpt":"","text":"关键字 minSdkVersion compileSdkVersion targetSdkVersion 学习目标了解各种sdkVersion具体意思。 正文Google 官方发布文章 解析compileSdkVersion、minSdkVersion 以及 targetSdkVersion 的含义，以及合理设置各个值的意义，还有翻译 minSdkVersion设置应用可运行最低版本，如果系统的 API 高于该值，则系统会阻止程序安装。 compileSdkVersion设置编辑版本，也就是告诉 Gradle 用哪个 Android SDK 版本编译你的应用，一般都是选择最新的SDK。 当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。（你真的应该修复这些警告，他们的出现一定是有原因的）。 在这里需要注意的是，编译报错的时候，一定要得到注意，根据提示来做兼容设置，例如判断Build.VERSION_SDK_INT常量表示当前Android设备的版本号来比对，使用不同的兼容方案。 targetSdkVersiontargetSdkVersion 是 Android 提供向前兼容的主要依据，在应用的 targetSdkVersion 没有更新之前系统不会应用最新的行为变化。 怎么理解这句话呢？如果设备API等于 targetSdkVersion 就是告知当前项目已经兼容新的行为变化。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Android 屏幕适配","slug":"Android-SmartScale","date":"2017-10-30T10:07:31.000Z","updated":"2018-01-18T10:19:11.548Z","comments":true,"path":"2017/10/30/Android-SmartScale/","link":"","permalink":"https://chunyang1988.github.io/2017/10/30/Android-SmartScale/","excerpt":"","text":"版权声明：本文转载自Android大牛stormzhang 原创文章，可以随意转载，但请必须在明确位置注明出处！！！ 众所周知，Android机型尺寸各种各样，于是屏幕适配就成了Android开发中很重要的一环。Android屏幕适配可能一些开发者都会遇到这样的问题，今天就来分享下屏幕适配，你会发现其实Android屏幕适配也可以很简单。 基本概念Android屏幕适配必须要理解的一些概念，这部分可能比较枯燥，但是俗话说的好“工欲善其事，必先利器”，翻译过来就是“有什么样的枪，决定你打什么样的鸟”，一旦这些概念你理解掌握了，屏幕适配你自然而然就觉得简单多了。 px 是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。 在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。如： 看这个色彩鲜艳的LED灯（原图大小） 你能想象这才是他的本来面目吗？（放大之后） in 表示英寸，是屏幕的物理尺寸。每英寸等于2.54厘米。例如我们经常说的手机屏幕大小有，5（英）寸、4（英）寸就是指这个单位。这些尺寸是屏幕的对角线长度。如果手机的屏幕是4英寸，表示手机的屏幕（可视区域）对角线长度是4 X 2.54 = 10.16厘米。 dpi dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。 density 屏幕密度，density和dpi的关系为 density = dpi/160 dp 也即dip，设备独立像素，device independent pixels的缩写，Android特有的单位，在屏幕密度dpi = 160屏幕上，1dp = 1px。 sp 和dp很类似，一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。 Android Drawable我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi drawable-ldpi (dpi=120, density=0.75) drawable-mdpi (dpi=160, density=1) drawable-hdpi (dpi=240, density=1.5) drawable-xhdpi (dpi=320, density=2) drawable-xxhdpi (dpi=480, density=3) 市面上的一些Android教程大多都是教的是为每种dpi都出一套图片资源，这个固然是一种解决办法，但同时也是一种非常笨的方法，为美工或者设计增加了不少的工作量不说，同时也会让你的apk包变的很大。那么有没有什么好的方法既能保证屏幕适配，又可以最小占用设计资源，同时最好又只使用一套dpi的图片资源呢？下面就来讲解下项目中总结出来的这个方法。 首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。 xhdpi成为首选上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规格的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。 设计资源紧张怎么办？在现在的App开发中，基本都会有iOS和Android版本，有些公司为了保持App不同版本的体验交互一致，还有些公司的设计资源可能比较紧张，这些情况下iOS和Android版本基本是一个设计师主导，而大多数情况下设计师可能更会以iPhone手机为基础进行设计，包括后期的切图之类的。这个时候身为Android开发人员你是否还要求设计师单独为Android端切一套图片资源呢？这会让你们的设计师崩溃的，下面就来告诉一个项目中总结的更棒的方法。 相信设计师们一般都会用最新的iPhone5（5s和5的尺寸以及分辨率都一样）来做原型设计，而iPhone5的屏幕分辨率为640X1164, 屏幕尺寸为4英寸，根据勾股定理(a^2 + b^2 = c^2)640^2+1164^2=1764496, 然后再对其开根号可求出屏幕对角线的分辨率为：1328，除以4可得出iphone5的dpi：1328/4≈332 可以看出iPhone5的屏幕的dpi约等于320, 刚好属于xhdpi，所以你可以很自豪的像你们的设计师说不用专门为Android端切图，直接把iPhone的那一套切好的图片资源放入drawable-xhdpi文件夹里就ok了。 wrap_content VS dpwrap_content和dp都是在Android开发中应该经常用到的，然后它们冥冥中是有关系的。 假设你看了这篇文章后都是统一有xhdpi的资源，那么你用wrap_content完全没有问题，Android会自动为其他规格的dpi屏幕适配,比如你在xhdpi放了一张120X120px大小的图片，那么在在hdpi屏幕上显示的就只有120/2*1.5=90px大小，但是如果你不小心同样把这张图片也放入了mdpi了，这个时候用wrap_content显示就会有问题，具体看下面的例子： 例如假设你只在drawable_xhdpi文件夹下放了test图片，xhdpi的设备会去xhdpi文件夹下找到test图片并直接显示，而mdpi的设备优先会去mdpi文件夹里查找test图片，但是没找到，最后在xhdpi文件夹下找到，然后会自动根据density计算并缩放显示出来，实际显示出来的大小是120/2=60px, 所以整体的显示比例才会看起来比较正常 mdpi xhdpi 但是如果你在mdpi文件夹里也放入了同样的图片，那么mdpi的设备会直接去mdpi文件夹里寻找到test图片，并直接显示，而这时候显示不会缩放，实际显示大小就是120X120,在mdpi的屏幕上看起来就会比较大，如图： 通过上面整个过程，大家应该理解了Android加载资源的整个过程, wrap_content同样可以用dp来代替，就拿上面这个例子，在xhdpi文件夹内放入了一张120X120像素的test图片，宽高直接除density就得出dp的数值，即这种情况下以下代码是等同的. 1234&lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test&quot; /&gt; 1234&lt;ImageView android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:src=&quot;@drawable/test&quot; /&gt; 总结相信通过以上的讲解，对Android UI中的一些基本概念有个很好的理解，实际开发工作中也有一些高效的方法可以参考，应该可以应对大部分的屏幕适配工作。但是项目中仍然有一些比较特殊的适配需求满足不了，以后会针对一些特殊的需求进行示例讲解。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"ADB 常用命令","slug":"adb-command","date":"2017-10-18T09:43:34.000Z","updated":"2018-01-18T09:51:07.084Z","comments":true,"path":"2017/10/18/adb-command/","link":"","permalink":"https://chunyang1988.github.io/2017/10/18/adb-command/","excerpt":"","text":"重启机器 1adb reboot 重启机器到bootloader刷机模式 1adb reboot bootloader 重启机器到recovery恢复模式 1adb reboot recovery 查看设备应用 123456adb shell pm ls packages //查看设备所有应用adb shell pm list packages -s //查看系统应用adb shell pm list packages -3 //查看第三方应用adb shell pm list packages &lt;name&gt; //查看包含&lt;name&gt;列表或者adb shell pm list packages | grep &lt;name&gt; 查看应用详情 1adb shell dumpsys package &lt;packagename&gt; 查看设备分辨率 123adb shell wm sizeadb shell wm size 480x1024 //修改分辨率adb shell wm size reset //恢复分辨率 查看屏幕密度 123adb shell wm densityadb shell wm density 160 //修改屏幕密度adb shell wm density reset //回复屏幕密度 查看系统版本 1adb shell getprop ro.build.version.release 强制停止应用 1adb shell am force-stop &lt;packagename&gt; 复制设备文件到电脑1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 复制电脑文件到设备 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 查看log日志 1adb logcat 查看内核日志 1adb shell dmesg 安装APk 1adb install [-lrtsdg] &lt;path_to_apk&gt;// adb install x.apk 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 卸载apk 1adb uninstall [-k] &lt;packagename&gt; 清除应用数据与缓存 12adb shell pm clear &lt;packagename&gt;//&lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据 还有部分功能是需要root的以及更多命令可以查看github","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Android Service","slug":"Android-Service","date":"2017-10-05T05:07:20.000Z","updated":"2018-01-18T10:19:26.954Z","comments":true,"path":"2017/10/05/Android-Service/","link":"","permalink":"https://chunyang1988.github.io/2017/10/05/Android-Service/","excerpt":"","text":"Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 服务基本上分为两种形式： 启动通过调用 startService() 启动服务时，服务即处于“启动”状态。核心在 onStartCommand()（允许组件启动服务） 绑定当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。核心在 onBind()（允许绑定服务） 注意： 使用服务的话，默认情况下，它仍会在应用的主线程中运行，因此，如果服务执行的是密集型或阻止性操作，则你仍应在服务内创建新线程。 通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。 android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名 方法介绍onStartCommand()通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。 onBind()通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。 onCreate()首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。 onDestroy()当服务不再使用且将被销毁时，系统将调用此方法。 使用介绍在这里面会介绍两种方式介绍，主要讲解的是绑定方式，因为绑定服务可以有很多交互方式。 A.启动服务通过调用startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。 B.绑定服务通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。 创建绑定服务时，必须提供IBinder接口，这里面可以通过三种方式定义： 1.扩展Binder类如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service 中可用的公共方法。也就是说如果服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 Binder 类，让你的客户端通过该类直接访问服务中的公共方法。 服务端代码如下： 123456789101112131415161718192021222324252627public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don&apos;t need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; 客户端代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We&apos;ve bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 通过上面方式就能是实现简单通信。 2.Messenger如需让服务与远程进程通信，则可使用 Messenger 为您的服务提供接口。利用此方法，您无需使用 AIDL 便可执行进程间通信 (IPC)。 服务端代码如下： 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), &quot;hello!&quot;, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), &quot;binding&quot;, Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 客户端代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported &apos;what&apos; value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 3.使用AIDLAIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，服务必须具备多线程处理能力，并采用线程安全式设计。 如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。 此文就不着重介绍，后续会单独有篇文章介绍。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Dagger2简单使用","slug":"Dagger2Simple","date":"2017-09-24T04:38:59.000Z","updated":"2018-01-18T09:49:43.925Z","comments":true,"path":"2017/09/24/Dagger2Simple/","link":"","permalink":"https://chunyang1988.github.io/2017/09/24/Dagger2Simple/","excerpt":"","text":"Dagger2是基于JSR—330标准的依赖注入框架，也就是在编译期间自动生成代码，来创建相应的对象。 Dagger2相应注释讲解此文讲解案例使用Retrofit讲解，讲解前先把常规写法写出来大家根据此对比，来发现Dagger2的便利之处。 1234567891011121314151617181920212223242526//创建OkHttpClientOkHttpClient.Builder client = new OkHttpClient.Builder();client.connectTimeout(15, TimeUnit.SECONDS);client.writeTimeout(30, TimeUnit.SECONDS);client.readTimeout(30, TimeUnit.SECONDS);//添加InterceptorHttpLoggingInterceptor logging = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; LogUtil.i(TAG, message); &#125;&#125;);logging.setLevel(HttpLoggingInterceptor.Level.BODY);client.addInterceptor(logging);client.addNetworkInterceptor(new StethoInterceptor());client.addNetworkInterceptor(new NetworkInterceptor());//创建Retrofit，传递OkHttpClient、HostUrlRetrofit retrofit = new Retrofit.Builder().client(client.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .baseUrl(HOST_URL).build(); //创建ApiServicemService = retrofit.create(ApiService.class); 大家都知道Retrofit中Api的调用都会放在ApiService中，那么使用Dagger2如何来获取到ApiService？如何创建Retrofit对象？如何传递OkHttpClient对象？大家先带着这样的问题来看此文。 @Inject@Inject负责标记那些需要被依赖注入自动创建出来，说白一点就是看见@Inject就代表这个对象在依赖注入中被引用或者被new出来。 在ApiModule中代码如下，先不用看非@Inject地方，后续会讲到。 123456789101112@Modulepublic class ApiModule &#123; String host; @Inject public ApiModule(String host) &#123; this.host = host; &#125; ...&#125; 在ApiManager属性中添加@Inject ApiService 1234567891011121314151617public class ApiManager &#123; private static class Holder &#123; private static ApiManager IN = new ApiManager(); &#125; public static ApiManager getInstance() &#123; return Holder.IN; &#125; @Inject ApiService apiService; public ApiManager() &#123; DaggerApiComponent.builder().apiModule(new ApiModule(&quot;&quot;)).build().inject(this); &#125;&#125; @Module通过@Module注解，Dagger才知道怎么去依赖注入，也就是上文中的@Inject的对象在此处查找并构造出来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Modulepublic class ApiModule &#123; String host; @Inject public ApiModule(String host) &#123; this.host = host; &#125; @Provides @SoApp public OkHttpClient okHttpClient() &#123; //创建OkHttpClient OkHttpClient.Builder client = new OkHttpClient.Builder(); client.connectTimeout(15, TimeUnit.SECONDS); client.writeTimeout(30, TimeUnit.SECONDS); client.readTimeout(30, TimeUnit.SECONDS); //添加Interceptor HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; LogUtil.i(TAG, message); &#125; &#125;); logging.setLevel(HttpLoggingInterceptor.Level.BODY); client.addInterceptor(logging); client.addNetworkInterceptor(new StethoInterceptor()); client.addNetworkInterceptor(new NetworkInterceptor()); return client.build(); &#125; @Provides @SoApp public ApiService apiService(String host, OkHttpClient client) &#123; //创建Retrofit，传递OkHttpClient、HostUrl Retrofit retrofit = new Retrofit.Builder().client(client) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(host) .build(); return retrofit.create(ApiService.class); &#125; @Provides String providesHost() &#123; return host; &#125;&#125; @Provides@Provides会标记Module中那些返回依赖的方法，通过此注解查找依赖引用，尤其是有些构造器会有很多参数，而这些参数必须在Module中添加@Provides的依赖方法，否则无法编译通过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Modulepublic class ApiModule &#123; String host; @Inject public ApiModule(String host) &#123; this.host = host; &#125; @Provides @SoApp public OkHttpClient okHttpClient() &#123; //创建OkHttpClient OkHttpClient.Builder client = new OkHttpClient.Builder(); client.connectTimeout(15, TimeUnit.SECONDS); client.writeTimeout(30, TimeUnit.SECONDS); client.readTimeout(30, TimeUnit.SECONDS); //添加Interceptor HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; LogUtil.i(TAG, message); &#125; &#125;); logging.setLevel(HttpLoggingInterceptor.Level.BODY); client.addInterceptor(logging); client.addNetworkInterceptor(new StethoInterceptor()); client.addNetworkInterceptor(new NetworkInterceptor()); return client.build(); &#125; @Provides @SoApp public ApiService apiService(String host, OkHttpClient client) &#123; //创建Retrofit，传递OkHttpClient、HostUrl Retrofit retrofit = new Retrofit.Builder().client(client) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(host) .build(); return retrofit.create(ApiService.class); &#125; @Provides String providesHost() &#123; return host; &#125;&#125; @Component在@Component里面定义了在哪些Module中去依赖注入，@Component通常是@Module和@Inject之间的桥梁。@Component也可以依赖其它的component，在此处先不讲解，后续讲解。 1234567@SoApp@Component(modules = &#123;ApiModule.class&#125;)public interface ApiComponent &#123; void inject(ApiManager manager);&#125; 使用在ApiManager属性中需要依赖注入的对象例如添加@Inject ApiService，Build Make Module 一下即可编译生成DaggerApiComponent.builder().apiModule(new ApiModule(&quot;&quot;)).build().inject(this); 1234567891011121314151617public class ApiManager &#123; private static class Holder &#123; private static ApiManager IN = new ApiManager(); &#125; public static ApiManager getInstance() &#123; return Holder.IN; &#125; @Inject ApiService apiService; public ApiManager() &#123; DaggerApiComponent.builder().apiModule(new ApiModule(&quot;&quot;)).build().inject(this); &#125;&#125; 到此基本的Dagger也就讲解完成了，文中还有@SoApp注解在下一个文章中讲解。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"树莓派3在Mac中安装步骤","slug":"RaspberryPIInstallStep","date":"2017-09-13T11:13:01.000Z","updated":"2018-01-18T09:49:17.048Z","comments":true,"path":"2017/09/13/RaspberryPIInstallStep/","link":"","permalink":"https://chunyang1988.github.io/2017/09/13/RaspberryPIInstallStep/","excerpt":"","text":"1.格式TF卡磁盘工具-&gt;抹掉TAB-&gt;MS_DOS(FAT) 2.查看挂载信息命令行中输入 df -h 查看相对应的TF卡路径如：/dev/disk2s1 3.卸载分区命令行输入diskutil numount 4.确定设备命令行输入diskutil list 主要目的是查看对应的路径名如：/dev/disk2 5.写入系统1sudo dd bs=4m if=固件名称.img of=上面确定的路径名 例如：sudo dd bs=4m if=LCD35-2016-03-18-raspbian-jessie.img of=/dev/rdisk2 6.卸载设备使用磁盘工具进行卸载即可","categories":[],"tags":[{"name":"Raspberry PI","slug":"Raspberry-PI","permalink":"https://chunyang1988.github.io/tags/Raspberry-PI/"},{"name":"树莓派","slug":"树莓派","permalink":"https://chunyang1988.github.io/tags/树莓派/"}]},{"title":"DataBinding","slug":"DataBinding","date":"2017-09-09T14:36:30.000Z","updated":"2018-01-18T09:48:42.221Z","comments":true,"path":"2017/09/09/DataBinding/","link":"","permalink":"https://chunyang1988.github.io/2017/09/09/DataBinding/","excerpt":"","text":"此文讲解的是MVVM中的Data Binding数据绑定 打开数据绑定在Model的gradle中添加： 123456android &#123; .... dataBinding &#123; enabled = true &#125;&#125; Data Binding Layout说明使用Data Binding后，可以将UI代码放到xml中，布局和数据更加紧密。 xml文件中，根节点为layout，之后data标签，在下面就是常用界面布局文件。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.lastName&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; data标签常用属性class属性class 自定义Binding名称，如果不写则默认是驼峰xml文件名+Binding，例如activity_main.xml则为ActivityMainBinding。如果有class = &quot;MainViewBinding&quot; 则直接这这个名字。 variable标签用于描述一个对象，之后在布局中引用使用，使用name表示对象引用时使用名称，type为要引用的对象。在View中用@{}来引用。例如 12345678&lt;variable name = &quot;user&quot; type = &quot;com.example.User&quot;/&gt;...&lt;TextView android:layout_width = &quot;warp_content&quot; android:layout_hight = &quot;warp_content&quot; android:text = &quot;@&#123;user.name&#125;&quot;/&gt; import标签导入跟Java用法一样，只要导入了当前类，后面引用的时候，就可以直接使用，不需要在制定路径例如： 123456789&lt;data&gt; &lt;import type=&quot;android.view.View&quot;/&gt;&lt;/data&gt;...&lt;TextView android:text=&quot;@&#123;user.lastName&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt; 123456789&lt;data&gt; &lt;import type=&quot;com.example.MyStringUtils&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;&lt;/data&gt;…&lt;TextView android:text=&quot;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; Binding 数据对象创建正确的数据对象才能在xml文件中引用，反之则会报错。主要就是对属性进行getXX、isXX等。 运算符 算术 + - / * % 字符串合并 + 逻辑 &amp;&amp; || 二元 &amp; | ^ 一元 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较 == &gt; &lt; &gt;= &lt;= Instanceof Grouping () 文字 - character, String, numeric, null Cast 方法调用 Field 访问 Array 访问 [] 三元 ?: 尚且不支持this,super,new,以及显示的泛型，还支持一种空合并运算符 1android:text = &quot;@&#123;user.displayName ?? user.lastName&#125;&quot; 还可以使用 123android:text=&quot;@&#123;@string/nameFormat(firstName, lastName)&#125;&quot;&lt;string name=&quot;nameFormat&quot;&gt;%s, %s&lt;/string&gt; 事件监听事件监听两种实现方式 方法引用 主要是使用名称::方法名格式，而Binding类中方法必须有View参数，要不然编译不通过。 123456789101112131415161718192021public class Handlers &#123; public void onClickFriend(View view) &#123; ... &#125;&#125;····&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;handlers&quot; type=&quot;com.example.Handlers&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot; android:onClick=&quot;@&#123;handlers::onClickFriend&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 监听器绑定使用() -&gt; 名称.方法(参数...) 123456789101112131415public class Presenter &#123; public void onSaveClick(Task task)&#123;&#125;&#125;···&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;task&quot; type=&quot;com.android.example.Task&quot; /&gt; &lt;variable name=&quot;presenter&quot; type=&quot;com.android.example.Presenter&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; ID Views只要是在xml中，带有id的View都会在Binding中通过public final 来修饰。直接调用也可以达到findViewById效果。 Observable动态更新数据 http://www.jianshu.com/p/b1df61a4df77http://blog.zhaiyifan.cn/2016/06/16/android-new-project-from-0-p7/http://www.jianshu.com/p/87d4b9f30960","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Gradle Wrapper 常用方法讲解","slug":"Gradlew","date":"2017-08-31T06:44:13.000Z","updated":"2018-03-20T06:38:35.733Z","comments":true,"path":"2017/08/31/Gradlew/","link":"","permalink":"https://chunyang1988.github.io/2017/08/31/Gradlew/","excerpt":"","text":"Gradle是一个基于Groovy强大的构建系统，此文讲解的是Android Studio所使用的一些常用命令。至于以后慢慢学习在讲解一些Gradle基础知识。 常用命令以下命令都是在Mac系统下的常用命令。 12345./gradlew -v # 版本号./gradlew clean # 清理项目build文件夹./gradlew build # 检查依赖并编译打包,同时把debug、release环境的包都打出来。与上文build相对应，一个是清理，一个是生成。./gradlew assembleDebug # 编译并打Debug包./gradlew assembleXxxRelease # 编译并打Release的包 这里面在讲解一下assemble的其他使用方法。 123./gradlew assembleXxxRelease # 生成Xxx渠道的Release版本包./gradlew assembleXxx # 生成Xxx渠道的Release和Debug版本包./gradlew assembleRelease # 生成全部渠道的Release版本包。 Xxx为渠道名称写法如下： 1234567891011android&#123;... productFlavors &#123; tencent&#123; ... ... &#125; ... &#125;...&#125; 完整版本如下： 12345678910// 友盟多渠道打包productFlavors &#123; tencent &#123;&#125; wandoujia &#123;&#125; host &#123;&#125;&#125;productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]&#125; 12345// AndroidManifest.xml清单中如下&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; /&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/categories/Android/"},{"name":"Gradle","slug":"Android/Gradle","permalink":"https://chunyang1988.github.io/categories/Android/Gradle/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://chunyang1988.github.io/tags/Gradle/"}]},{"title":"Toolbar基本使用","slug":"ToolBar","date":"2017-08-18T14:26:05.000Z","updated":"2018-01-18T09:47:25.847Z","comments":true,"path":"2017/08/18/ToolBar/","link":"","permalink":"https://chunyang1988.github.io/2017/08/18/ToolBar/","excerpt":"","text":"此文讲解的Toolbar为V7包中的Toolbar。此文会有很多不成熟地方，请大家指正。 设置样式首先使用Toolbar需要先更改Style样式，主要是将样式设置成无Actionbar的样式，当然网上也有很多其他方式，本人使用的代码如下： 1234567891011&lt;style name=&quot;AppTheme&quot; parent=&quot;AppTheme.Base&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme.Base&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;/style&gt; 官方文档中XML资源 常用参数以及方法说明1.基本使用12345678910111213&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; tools:logo=&quot;@mipmap/ic_launcher&quot; tools:navigationIcon=&quot;@drawable/ic_acb_list&quot; tools:subtitle=&quot;@string/app_name&quot; tools:subtitleTextColor=&quot;@color/colorAccent&quot; tools:title=&quot;@string/app_name&quot; tools:titleTextColor=&quot;@android:color/white&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt; tools中的参数如下图解释 代码实现如下： 12345678Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);toolbar.setNavigationIcon(R.drawable.ic_acb_list);//设置导航栏图标toolbar.setLogo(R.mipmap.ic_launcher);//设置app logotoolbar.setTitle(&quot;Toolbar&quot;);//设置主标题toolbar.setTitleTextColor(ContextCompat.getColor(this, android.R.color.white));toolbar.setSubtitle(&quot;Subtitle&quot;);//设置子标题toolbar.setSubtitleTextColor(ContextCompat.getColor(this, R.color.colorAccent)); 2.菜单使用主代码部分 1234567891011121314151617181920212223toolbar.setOverflowIcon(ContextCompat.getDrawable(this, R.drawable.ic_acb_list));//设置更多图标toolbar.inflateMenu(R.menu.main_menu);toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; int id = item.getItemId(); Toast.makeText(MainActivity.this, String.valueOf(id), Toast.LENGTH_SHORT).show(); switch (id) &#123; case R.id.action_1: break; case R.id.action_2: break; case R.id.action_3: break; case R.id.action_4: break; case R.id.action_5: break; &#125; return false; &#125;&#125;); menu部分 123456789101112131415161718192021222324252627282930&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_3&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_4&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_5&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt;&lt;/menu&gt; 3.特殊说明A.TextAppearnce Toolbar当然也可以自定义样式，例如自定义Title字体大小,字体颜色等等基本信息，这时候会使用到一个属性TextAppearance TextAppearance：可以从新定义Style，接着看代码： 1234&lt;style name=&quot;Toolbar.Title&quot; parent=&quot;@style/TextAppearance.Widget.AppCompat.Toolbar.Title&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;22sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; 其中上面中将字体大小已经字体颜色都改变。特别说明，如果你前面已经定义了颜色后面又调用了TextAppearance，那面你之前设置都按照你新定义的Appearance来实现. B.PopupStyle 123&lt;style name=&quot;Toolbar.Popup&quot; parent=&quot;@style/Widget.AppCompat.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt;&lt;/style&gt; 默认情况overlapAnchor为true，而这样在弹出更多菜单的时候，会覆盖标题栏弹出，如果这是false则不会覆盖标题栏。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"App启动优化","slug":"AppStartup","date":"2017-08-11T14:49:33.000Z","updated":"2018-01-18T09:46:52.116Z","comments":true,"path":"2017/08/11/AppStartup/","link":"","permalink":"https://chunyang1988.github.io/2017/08/11/AppStartup/","excerpt":"","text":"启动白屏每次令启动的时候，会出现一个白屏现象引起原因：1.Application的onCreate做了大量初始化操作；建议：可以放到开始使用的地方初始化操作；2.Activity的onCreate中有很多复杂布局与渲染操作；建议：仅初始化自己需要的对象，xml布局减少嵌套布局； 优化方案1.关闭启动窗口 建立style 123&lt;style name=&quot;AppTheme.Launcher&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 引用style，只需要在MAIN中引用 123&lt;activity android:theme=&quot;@style/AppTheme.Launcher&quot; /&gt; 这样做虽然没有白屏了，但是会出现点击桌面图标不会立即反应的现象。 2.使用Material Design规范 建立style 123&lt;style name=&quot;AppTheme.Launcher.MD&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/launch_material_design&lt;/item&gt;&lt;/style&gt; 这里面更上面不同的就是使用layer-list方式制作一个简单启动页面","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"炫酷终端","slug":"CoolShell","date":"2017-08-03T07:14:41.000Z","updated":"2017-08-06T03:08:02.000Z","comments":true,"path":"2017/08/03/CoolShell/","link":"","permalink":"https://chunyang1988.github.io/2017/08/03/CoolShell/","excerpt":"","text":"此文讲解的是通过oh_my_zsh来打造个性界面。建议Mac系统使用Iterm2 + oh_my_zsh进行打造炫酷终端。 Installation 安装根据需求进行如下操作，如在终端中可以直接输入 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 即可安装。 via curl 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; via wget 1sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装完成后，在用户目录有个隐藏文件夹.oh-my-zsh可以使用命令行查看 1cd ~/.oh-my-zsh Updates 升级默认情况下，系统会每隔几周检测升级，发现更新后提示用户进行更新。当然我们也可以关闭提示自动升级，还可以直接关闭自动升级功能。 开关提示升级DISABLE_UPDATE_PROMPT = true 开关自动升级DISABLE_AUTO_UPDATE = true 对~/.zshrc进行编辑。建议使用vi或者vim进行编辑更改。 手动升级在终端中输入upgrade_oh_my_zsh Edit Themes 更换主题所有主题都在~/.oh-my-zsh/themes目录中，想要预览可以看官网地址 更换主题以及操作升级开关，都是在~/.zshrc中进行编辑。 使用vi或者vim对~/.zshrc进行编辑 ZSH_THEME=&quot;robbyrussell&quot;等于号后面写上你要替换的主题名称即可。例如ZSH_THEME=&quot;af-magic&quot;。 Uninstall 卸载卸载oh_my_zsh只需要运行uninstall_oh_my_zsh即可。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://chunyang1988.github.io/categories/Tools/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://chunyang1988.github.io/tags/Shell/"}]},{"title":"搭建个人博客","slug":"Blog","date":"2017-08-01T08:46:50.000Z","updated":"2017-08-07T13:51:13.000Z","comments":true,"path":"2017/08/01/Blog/","link":"","permalink":"https://chunyang1988.github.io/2017/08/01/Blog/","excerpt":"","text":"此文讲解的搭建个人博客是通过GitHub Pages + Hexo进行搭建。 1.安装Hexo安装前需要需要确定是否安装Node.js以及Git，在此文我会重头一步一步安装操作。 a.安装 HomebrewHomebrew是 macOS 缺失的软件包管理器，具体哪些好处问什么要安装还是自行搜索吧。 安装只需要在终端中输入: 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装成功后，直接就可以使用brew进行安装Node以及Git了，当然可以安装的还有很多东西，就不列举了。 b.安装Node官网安装Node也可以，但是此文讲解的是通过brew进行安装，大家一起看看Homebrew的优点。 同样只需要在终端中输入: 1brew install node c.安装Git此处就不多说了直接上代码: 1brew install git d.安装Hexo至此准备工作都已经完成可以，开始安装Hex代码如下： 1npm install -g hexo-cli 2.建站初步环境都已经完成，剩下的就是建站了，运行一下命令即可完成建站操作。 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 并不一定非要按照上述代码去写，也可以这样写 1234mkdir &lt;folder&gt;cd &lt;folder&gt;hexo initnpm install 例如： 1234mkdir Blogscd Blogshexo init npm install 完成后目录结构如下 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 具体什么意思，这里面就不废话了，可以看官网 3.简单写作此处不会过度介绍，详情还是去看官网，在这里面只是简单介绍几种常用命令。 a.新建文章1hexo new [layout] &lt;title&gt; 其中[layout]有三种默认布局：post、page、draft，分别对应不同路径。 布局 路径 post source/_posts page source draft source/_drafts 例如： 1hexo new blogs b.更改主题使用maupassant主题为介绍 123git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassantnpm install hexo-renderer-jade@0.3.0 --savenpm install hexo-renderer-sass --save 将主题下载到指定目录，更改配置文件_config.ym里面的theme 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: maupassant 每个主题安装方式不一样，具体的说明看官网更加详细。 4.部署a.创建Github Pages这里面不多说，主要是创建一个yourName.github.io仓库 b.部署Hexo到Github这里面主要介绍使用hexo deploy部署到git上面 在配置文件_config.yml中配置deploy 1234deploy: type: git repo: git@github.com:yuserName/yuserName.github.io.git branch: master 例如： 1234deploy: type: git repo: git@github.com:Chunyang1988/chunyang1988.github.io.git branch: master 之后一件部署 1hexo deploy c.添加SSH密钥生成密钥 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 例如 1ssh-keygen -t rsa -C &quot;chunyang1988.cn@gmail.com&quot; 为了方便在后面提示信息中，直接按回车，一直回车下来。 d.部署部署前还需要安装 1npm install hexo-deployer-git --save 一般现在本地写好文章，运行 1hexo s 本地查看一下，如果可以，可以直接部署到git上面 1hexo d 结束这时候你输入自己的xxx.github.io即可查看自己的博客了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chunyang1988.github.io/tags/Hexo/"}]}]}