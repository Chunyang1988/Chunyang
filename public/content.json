{"meta":{"title":"Chunyang1988","subtitle":null,"description":null,"author":"Chunyang1988","url":"https://chunyang1988.github.io"},"pages":[{"title":"关于","date":"2017-08-03T15:04:14.000Z","updated":"2017-08-03T15:04:14.000Z","comments":false,"path":"about/index.html","permalink":"https://chunyang1988.github.io/about/index.html","excerpt":"","text":"chunyang1988，一个98年出生的小伙 只是想弄一个博客，写写日记，写写技术而已让自己有件事情做，不停的思考与进步没有太多功底，一步一步开始学习不想说太多，希望能够进步一切皆有可能相信自己"}],"posts":[{"title":"ADB 常用命令","slug":"adb-command","date":"2017-10-18T09:43:34.000Z","updated":"2018-01-18T09:51:07.084Z","comments":true,"path":"2017/10/18/adb-command/","link":"","permalink":"https://chunyang1988.github.io/2017/10/18/adb-command/","excerpt":"","text":"重启机器 1adb reboot 重启机器到bootloader刷机模式 1adb reboot bootloader 重启机器到recovery恢复模式 1adb reboot recovery 查看设备应用 123456adb shell pm ls packages //查看设备所有应用adb shell pm list packages -s //查看系统应用adb shell pm list packages -3 //查看第三方应用adb shell pm list packages &lt;name&gt; //查看包含&lt;name&gt;列表或者adb shell pm list packages | grep &lt;name&gt; 查看应用详情 1adb shell dumpsys package &lt;packagename&gt; 查看设备分辨率 123adb shell wm sizeadb shell wm size 480x1024 //修改分辨率adb shell wm size reset //恢复分辨率 查看屏幕密度 123adb shell wm densityadb shell wm density 160 //修改屏幕密度adb shell wm density reset //回复屏幕密度 查看系统版本 1adb shell getprop ro.build.version.release 强制停止应用 1adb shell am force-stop &lt;packagename&gt; 复制设备文件到电脑1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 复制电脑文件到设备 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 查看log日志 1adb logcat 查看内核日志 1adb shell dmesg 安装APk 1adb install [-lrtsdg] &lt;path_to_apk&gt;// adb install x.apk 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 卸载apk 1adb uninstall [-k] &lt;packagename&gt; 清除应用数据与缓存 12adb shell pm clear &lt;packagename&gt;//&lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据 还有部分功能是需要root的以及更多命令可以查看github","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Android Service","slug":"Android-Service","date":"2017-10-05T05:07:20.000Z","updated":"2018-01-18T09:50:51.606Z","comments":true,"path":"2017/10/05/Android-Service/","link":"","permalink":"https://chunyang1988.github.io/2017/10/05/Android-Service/","excerpt":"","text":"Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 服务基本上分为两种形式： 启动通过调用 startService() 启动服务时，服务即处于“启动”状态。核心在 onStartCommand()（允许组件启动服务） 绑定当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。核心在 onBind()（允许绑定服务） 注意： 使用服务的话，默认情况下，它仍会在应用的主线程中运行，因此，如果服务执行的是密集型或阻止性操作，则你仍应在服务内创建新线程。 通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。 android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名 方法介绍onStartCommand()通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。 onBind()通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。 onCreate()首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。 onDestroy()当服务不再使用且将被销毁时，系统将调用此方法。 使用介绍在这里面会介绍两种方式介绍，主要讲解的是绑定方式，因为绑定服务可以有很多交互方式。 A.启动服务通过调用startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。 B.绑定服务通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。 创建绑定服务时，必须提供IBinder接口，这里面可以通过三种方式定义： 1.扩展Binder类如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service 中可用的公共方法。也就是说如果服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 Binder 类，让你的客户端通过该类直接访问服务中的公共方法。 服务端代码如下： 123456789101112131415161718192021222324252627public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don&apos;t need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; 客户端代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We&apos;ve bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 通过上面方式就能是实现简单通信。 2.Messenger如需让服务与远程进程通信，则可使用 Messenger 为您的服务提供接口。利用此方法，您无需使用 AIDL 便可执行进程间通信 (IPC)。 服务端代码如下： 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), &quot;hello!&quot;, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), &quot;binding&quot;, Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 客户端代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported &apos;what&apos; value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 3.使用AIDLAIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，服务必须具备多线程处理能力，并采用线程安全式设计。 如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。 此文就不着重介绍，后续会单独有篇文章介绍。","categories":[],"tags":[]},{"title":"Dagger2简单使用","slug":"Dagger2Simple","date":"2017-09-24T04:38:59.000Z","updated":"2018-01-18T09:49:43.925Z","comments":true,"path":"2017/09/24/Dagger2Simple/","link":"","permalink":"https://chunyang1988.github.io/2017/09/24/Dagger2Simple/","excerpt":"","text":"Dagger2是基于JSR—330标准的依赖注入框架，也就是在编译期间自动生成代码，来创建相应的对象。 Dagger2相应注释讲解此文讲解案例使用Retrofit讲解，讲解前先把常规写法写出来大家根据此对比，来发现Dagger2的便利之处。 1234567891011121314151617181920212223242526//创建OkHttpClientOkHttpClient.Builder client = new OkHttpClient.Builder();client.connectTimeout(15, TimeUnit.SECONDS);client.writeTimeout(30, TimeUnit.SECONDS);client.readTimeout(30, TimeUnit.SECONDS);//添加InterceptorHttpLoggingInterceptor logging = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; LogUtil.i(TAG, message); &#125;&#125;);logging.setLevel(HttpLoggingInterceptor.Level.BODY);client.addInterceptor(logging);client.addNetworkInterceptor(new StethoInterceptor());client.addNetworkInterceptor(new NetworkInterceptor());//创建Retrofit，传递OkHttpClient、HostUrlRetrofit retrofit = new Retrofit.Builder().client(client.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .baseUrl(HOST_URL).build(); //创建ApiServicemService = retrofit.create(ApiService.class); 大家都知道Retrofit中Api的调用都会放在ApiService中，那么使用Dagger2如何来获取到ApiService？如何创建Retrofit对象？如何传递OkHttpClient对象？大家先带着这样的问题来看此文。 @Inject@Inject负责标记那些需要被依赖注入自动创建出来，说白一点就是看见@Inject就代表这个对象在依赖注入中被引用或者被new出来。 在ApiModule中代码如下，先不用看非@Inject地方，后续会讲到。 123456789101112@Modulepublic class ApiModule &#123; String host; @Inject public ApiModule(String host) &#123; this.host = host; &#125; ...&#125; 在ApiManager属性中添加@Inject ApiService 1234567891011121314151617public class ApiManager &#123; private static class Holder &#123; private static ApiManager IN = new ApiManager(); &#125; public static ApiManager getInstance() &#123; return Holder.IN; &#125; @Inject ApiService apiService; public ApiManager() &#123; DaggerApiComponent.builder().apiModule(new ApiModule(&quot;&quot;)).build().inject(this); &#125;&#125; @Module通过@Module注解，Dagger才知道怎么去依赖注入，也就是上文中的@Inject的对象在此处查找并构造出来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Modulepublic class ApiModule &#123; String host; @Inject public ApiModule(String host) &#123; this.host = host; &#125; @Provides @SoApp public OkHttpClient okHttpClient() &#123; //创建OkHttpClient OkHttpClient.Builder client = new OkHttpClient.Builder(); client.connectTimeout(15, TimeUnit.SECONDS); client.writeTimeout(30, TimeUnit.SECONDS); client.readTimeout(30, TimeUnit.SECONDS); //添加Interceptor HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; LogUtil.i(TAG, message); &#125; &#125;); logging.setLevel(HttpLoggingInterceptor.Level.BODY); client.addInterceptor(logging); client.addNetworkInterceptor(new StethoInterceptor()); client.addNetworkInterceptor(new NetworkInterceptor()); return client.build(); &#125; @Provides @SoApp public ApiService apiService(String host, OkHttpClient client) &#123; //创建Retrofit，传递OkHttpClient、HostUrl Retrofit retrofit = new Retrofit.Builder().client(client) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(host) .build(); return retrofit.create(ApiService.class); &#125; @Provides String providesHost() &#123; return host; &#125;&#125; @Provides@Provides会标记Module中那些返回依赖的方法，通过此注解查找依赖引用，尤其是有些构造器会有很多参数，而这些参数必须在Module中添加@Provides的依赖方法，否则无法编译通过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Modulepublic class ApiModule &#123; String host; @Inject public ApiModule(String host) &#123; this.host = host; &#125; @Provides @SoApp public OkHttpClient okHttpClient() &#123; //创建OkHttpClient OkHttpClient.Builder client = new OkHttpClient.Builder(); client.connectTimeout(15, TimeUnit.SECONDS); client.writeTimeout(30, TimeUnit.SECONDS); client.readTimeout(30, TimeUnit.SECONDS); //添加Interceptor HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; LogUtil.i(TAG, message); &#125; &#125;); logging.setLevel(HttpLoggingInterceptor.Level.BODY); client.addInterceptor(logging); client.addNetworkInterceptor(new StethoInterceptor()); client.addNetworkInterceptor(new NetworkInterceptor()); return client.build(); &#125; @Provides @SoApp public ApiService apiService(String host, OkHttpClient client) &#123; //创建Retrofit，传递OkHttpClient、HostUrl Retrofit retrofit = new Retrofit.Builder().client(client) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(host) .build(); return retrofit.create(ApiService.class); &#125; @Provides String providesHost() &#123; return host; &#125;&#125; @Component在@Component里面定义了在哪些Module中去依赖注入，@Component通常是@Module和@Inject之间的桥梁。@Component也可以依赖其它的component，在此处先不讲解，后续讲解。 1234567@SoApp@Component(modules = &#123;ApiModule.class&#125;)public interface ApiComponent &#123; void inject(ApiManager manager);&#125; 使用在ApiManager属性中需要依赖注入的对象例如添加@Inject ApiService，Build Make Module 一下即可编译生成DaggerApiComponent.builder().apiModule(new ApiModule(&quot;&quot;)).build().inject(this); 1234567891011121314151617public class ApiManager &#123; private static class Holder &#123; private static ApiManager IN = new ApiManager(); &#125; public static ApiManager getInstance() &#123; return Holder.IN; &#125; @Inject ApiService apiService; public ApiManager() &#123; DaggerApiComponent.builder().apiModule(new ApiModule(&quot;&quot;)).build().inject(this); &#125;&#125; 到此基本的Dagger也就讲解完成了，文中还有@SoApp注解在下一个文章中讲解。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"树莓派3在Mac中安装步骤","slug":"RaspberryPIInstallStep","date":"2017-09-13T11:13:01.000Z","updated":"2018-01-18T09:49:17.048Z","comments":true,"path":"2017/09/13/RaspberryPIInstallStep/","link":"","permalink":"https://chunyang1988.github.io/2017/09/13/RaspberryPIInstallStep/","excerpt":"","text":"1.格式TF卡磁盘工具-&gt;抹掉TAB-&gt;MS_DOS(FAT) 2.查看挂载信息命令行中输入 df -h 查看相对应的TF卡路径如：/dev/disk2s1 3.卸载分区命令行输入diskutil numount 4.确定设备命令行输入diskutil list 主要目的是查看对应的路径名如：/dev/disk2 5.写入系统1sudo dd bs=4m if=固件名称.img of=上面确定的路径名 例如：sudo dd bs=4m if=LCD35-2016-03-18-raspbian-jessie.img of=/dev/rdisk2 6.卸载设备使用磁盘工具进行卸载即可","categories":[],"tags":[{"name":"Raspberry PI","slug":"Raspberry-PI","permalink":"https://chunyang1988.github.io/tags/Raspberry-PI/"},{"name":"树莓派","slug":"树莓派","permalink":"https://chunyang1988.github.io/tags/树莓派/"}]},{"title":"DataBinding","slug":"DataBinding","date":"2017-09-09T14:36:30.000Z","updated":"2018-01-18T09:48:42.221Z","comments":true,"path":"2017/09/09/DataBinding/","link":"","permalink":"https://chunyang1988.github.io/2017/09/09/DataBinding/","excerpt":"","text":"此文讲解的是MVVM中的Data Binding数据绑定 打开数据绑定在Model的gradle中添加： 123456android &#123; .... dataBinding &#123; enabled = true &#125;&#125; Data Binding Layout说明使用Data Binding后，可以将UI代码放到xml中，布局和数据更加紧密。 xml文件中，根节点为layout，之后data标签，在下面就是常用界面布局文件。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.lastName&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; data标签常用属性class属性class 自定义Binding名称，如果不写则默认是驼峰xml文件名+Binding，例如activity_main.xml则为ActivityMainBinding。如果有class = &quot;MainViewBinding&quot; 则直接这这个名字。 variable标签用于描述一个对象，之后在布局中引用使用，使用name表示对象引用时使用名称，type为要引用的对象。在View中用@{}来引用。例如 12345678&lt;variable name = &quot;user&quot; type = &quot;com.example.User&quot;/&gt;...&lt;TextView android:layout_width = &quot;warp_content&quot; android:layout_hight = &quot;warp_content&quot; android:text = &quot;@&#123;user.name&#125;&quot;/&gt; import标签导入跟Java用法一样，只要导入了当前类，后面引用的时候，就可以直接使用，不需要在制定路径例如： 123456789&lt;data&gt; &lt;import type=&quot;android.view.View&quot;/&gt;&lt;/data&gt;...&lt;TextView android:text=&quot;@&#123;user.lastName&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt; 123456789&lt;data&gt; &lt;import type=&quot;com.example.MyStringUtils&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;&lt;/data&gt;…&lt;TextView android:text=&quot;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; Binding 数据对象创建正确的数据对象才能在xml文件中引用，反之则会报错。主要就是对属性进行getXX、isXX等。 运算符 算术 + - / * % 字符串合并 + 逻辑 &amp;&amp; || 二元 &amp; | ^ 一元 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较 == &gt; &lt; &gt;= &lt;= Instanceof Grouping () 文字 - character, String, numeric, null Cast 方法调用 Field 访问 Array 访问 [] 三元 ?: 尚且不支持this,super,new,以及显示的泛型，还支持一种空合并运算符 1android:text = &quot;@&#123;user.displayName ?? user.lastName&#125;&quot; 还可以使用 123android:text=&quot;@&#123;@string/nameFormat(firstName, lastName)&#125;&quot;&lt;string name=&quot;nameFormat&quot;&gt;%s, %s&lt;/string&gt; 事件监听事件监听两种实现方式 方法引用 主要是使用名称::方法名格式，而Binding类中方法必须有View参数，要不然编译不通过。 123456789101112131415161718192021public class Handlers &#123; public void onClickFriend(View view) &#123; ... &#125;&#125;····&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;handlers&quot; type=&quot;com.example.Handlers&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot; android:onClick=&quot;@&#123;handlers::onClickFriend&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 监听器绑定使用() -&gt; 名称.方法(参数...) 123456789101112131415public class Presenter &#123; public void onSaveClick(Task task)&#123;&#125;&#125;···&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;task&quot; type=&quot;com.android.example.Task&quot; /&gt; &lt;variable name=&quot;presenter&quot; type=&quot;com.android.example.Presenter&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; ID Views只要是在xml中，带有id的View都会在Binding中通过public final 来修饰。直接调用也可以达到findViewById效果。 Observable动态更新数据 http://www.jianshu.com/p/b1df61a4df77http://blog.zhaiyifan.cn/2016/06/16/android-new-project-from-0-p7/http://www.jianshu.com/p/87d4b9f30960","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Gradle Wrapper 常用方法讲解","slug":"Gradlew","date":"2017-08-31T06:44:13.000Z","updated":"2018-01-18T09:48:16.148Z","comments":true,"path":"2017/08/31/Gradlew/","link":"","permalink":"https://chunyang1988.github.io/2017/08/31/Gradlew/","excerpt":"","text":"Gradle是一个基于Groovy强大的构建系统，此文讲解的是Android Studio所使用的一些常用命令。至于以后慢慢学习在讲解一些Gradle基础知识。 常用命令以下命令都是在Mac系统下的常用命令。 12345./gradlew -v # 版本号./gradlew clean # 清理项目build文件夹./gradlew build # 检查依赖并编译打包,同时把debug、release环境的包都打出来。与上文build相对应，一个是清理，一个是生成。./gradlew assembleDebug # 编译并打Debug包./gradlew assembleXxxRelease # 编译并打Release的包 这里面在讲解一下assemble的其他使用方法。 123./gradlew assembleXxxRelease # 生成Xxx渠道的Release版本包./gradlew assembleXxx # 生成Xxx渠道的Release和Debug版本包./gradlew assembleRelease # 生成全部渠道的Release版本包。 Xxx为渠道名称写法如下： 1234567891011android&#123;... productFlavors &#123; tencent&#123; ... ... &#125; ... &#125;...&#125; 完整版本如下： 12345678910// 友盟多渠道打包productFlavors &#123; tencent &#123;&#125; wandoujia &#123;&#125; host &#123;&#125;&#125;productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]&#125; 12345// AndroidManifest.xml清单中如下&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; /&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Android动态授权那些事","slug":"SelfPermission","date":"2017-08-25T14:02:33.000Z","updated":"2018-01-18T09:47:53.803Z","comments":true,"path":"2017/08/25/SelfPermission/","link":"","permalink":"https://chunyang1988.github.io/2017/08/25/SelfPermission/","excerpt":"","text":"Android6.0(API 23)以后推出了很多新特性，其中 动态授权 对于开发人员来说带了很多麻烦，此文将说说动态授权那些事。 好在google已经给出了解决方案，答案都在support-v4-24.1.0包中。首先最重要的两个类ActivityCompat，ContextCompat。 ContextCompat类检测是否有相应权限permission，如果有则返回PackageManager.PERMISSION_DENIED。 public static int checkSelfPermission(@NonNull Context context, @NonNull String permission) ActivityCompat类请求权限 public static void requestPermissions(final @NonNull Activity activity,final @NonNull String[] permissions, final int requestCode) Activity类返回请求权限返回 public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 说明关于动态授权，核心代码无非就上面几个方法的使用。要想明白如何来动态获取权限，首先要知道其交互流程。 按照上图所示，分解步骤1.检查所需权限是否获取2.请求所有权限3.友好提示用户，手动获取权限方法。4.结束 步骤方法a.检查权限是否获取使用// 判断权限集合 public boolean checkPermissions(String... permissions) { for (String permission : permissions) { if (checkPermission(context, permission)) return true; } return false; } // 判断是否缺少权限 private boolean checkPermission(Context context, String permission) { return ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_DENIED; } 如果有为获取权限则请求权限 b.请求权限// 请求权限兼容低版本 public void requestPermissions(String... permissions) { ActivityCompat.requestPermissions(activity, permissions, PERMISSION_REQUEST_CODE); } 使用系统权限对话框提示用户是否授权，如有拒绝获取权限的地方，则优化提示用户手动获取权限方法。 c.手动获取权限提示。private void showPermissionDialog() { AlertDialog.Builder builder = new AlertDialog.Builder(activity); builder.setTitle(&quot;帮助&quot;); builder.setMessage(&quot;当前应用缺少必要权限。\\n\\n请点击\\&quot;设置\\&quot;-\\&quot;权限\\&quot;-打开所需权限。&quot;);///n/n最后点击两次后退按钮，即可返回。 // 拒绝, 退出应用 builder.setNegativeButton(&quot;退出&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { activity.setResult(PERMISSIONS_DENIED); activity.finish(); } }); builder.setPositiveButton(&quot;设置&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { startAppSettings(); } }); builder.setCancelable(false); builder.show(); } // 启动应用的设置 private void startAppSettings() { Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.parse(PACKAGE_URL_SCHEME + activity.getPackageName())); activity.startActivity(intent); } d.结束使用a.初始化mCheckPermission = new CheckPermission(this) { @Override String[] getPermissions() { return new String[]{ Manifest.permission.CAMERA }; } }; b.检查权限 @Override protected void onResume() { super.onResume(); mCheckPermission.checkPermission(); } c.实现onRequestPermissionsResult @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); mCheckPermission.checkRequestPermissionsResult(requestCode, grantResults); } 具体代码可以看我的ZXingScan PS:欢迎大家支持我的，Github","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"Toolbar基本使用","slug":"ToolBar","date":"2017-08-18T14:26:05.000Z","updated":"2018-01-18T09:47:25.847Z","comments":true,"path":"2017/08/18/ToolBar/","link":"","permalink":"https://chunyang1988.github.io/2017/08/18/ToolBar/","excerpt":"","text":"此文讲解的Toolbar为V7包中的Toolbar。此文会有很多不成熟地方，请大家指正。 设置样式首先使用Toolbar需要先更改Style样式，主要是将样式设置成无Actionbar的样式，当然网上也有很多其他方式，本人使用的代码如下： 1234567891011&lt;style name=&quot;AppTheme&quot; parent=&quot;AppTheme.Base&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme.Base&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;/style&gt; 官方文档中XML资源 常用参数以及方法说明1.基本使用12345678910111213&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; tools:logo=&quot;@mipmap/ic_launcher&quot; tools:navigationIcon=&quot;@drawable/ic_acb_list&quot; tools:subtitle=&quot;@string/app_name&quot; tools:subtitleTextColor=&quot;@color/colorAccent&quot; tools:title=&quot;@string/app_name&quot; tools:titleTextColor=&quot;@android:color/white&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt; tools中的参数如下图解释 代码实现如下： 12345678Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);toolbar.setNavigationIcon(R.drawable.ic_acb_list);//设置导航栏图标toolbar.setLogo(R.mipmap.ic_launcher);//设置app logotoolbar.setTitle(&quot;Toolbar&quot;);//设置主标题toolbar.setTitleTextColor(ContextCompat.getColor(this, android.R.color.white));toolbar.setSubtitle(&quot;Subtitle&quot;);//设置子标题toolbar.setSubtitleTextColor(ContextCompat.getColor(this, R.color.colorAccent)); 2.菜单使用主代码部分 1234567891011121314151617181920212223toolbar.setOverflowIcon(ContextCompat.getDrawable(this, R.drawable.ic_acb_list));//设置更多图标toolbar.inflateMenu(R.menu.main_menu);toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; int id = item.getItemId(); Toast.makeText(MainActivity.this, String.valueOf(id), Toast.LENGTH_SHORT).show(); switch (id) &#123; case R.id.action_1: break; case R.id.action_2: break; case R.id.action_3: break; case R.id.action_4: break; case R.id.action_5: break; &#125; return false; &#125;&#125;); menu部分 123456789101112131415161718192021222324252627282930&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_3&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_4&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/action_5&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/app_name&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt;&lt;/menu&gt; 3.特殊说明A.TextAppearnce Toolbar当然也可以自定义样式，例如自定义Title字体大小,字体颜色等等基本信息，这时候会使用到一个属性TextAppearance TextAppearance：可以从新定义Style，接着看代码： 1234&lt;style name=&quot;Toolbar.Title&quot; parent=&quot;@style/TextAppearance.Widget.AppCompat.Toolbar.Title&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;22sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; 其中上面中将字体大小已经字体颜色都改变。特别说明，如果你前面已经定义了颜色后面又调用了TextAppearance，那面你之前设置都按照你新定义的Appearance来实现. B.PopupStyle 123&lt;style name=&quot;Toolbar.Popup&quot; parent=&quot;@style/Widget.AppCompat.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt;&lt;/style&gt; 默认情况overlapAnchor为true，而这样在弹出更多菜单的时候，会覆盖标题栏弹出，如果这是false则不会覆盖标题栏。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"App启动优化","slug":"AppStartup","date":"2017-08-11T14:49:33.000Z","updated":"2018-01-18T09:46:52.116Z","comments":true,"path":"2017/08/11/AppStartup/","link":"","permalink":"https://chunyang1988.github.io/2017/08/11/AppStartup/","excerpt":"","text":"启动白屏每次令启动的时候，会出现一个白屏现象引起原因：1.Application的onCreate做了大量初始化操作；建议：可以放到开始使用的地方初始化操作；2.Activity的onCreate中有很多复杂布局与渲染操作；建议：仅初始化自己需要的对象，xml布局减少嵌套布局； 优化方案1.关闭启动窗口 建立style 123&lt;style name=&quot;AppTheme.Launcher&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 引用style，只需要在MAIN中引用 123&lt;activity android:theme=&quot;@style/AppTheme.Launcher&quot; /&gt; 这样做虽然没有白屏了，但是会出现点击桌面图标不会立即反应的现象。 2.使用Material Design规范 建立style 123&lt;style name=&quot;AppTheme.Launcher.MD&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/launch_material_design&lt;/item&gt;&lt;/style&gt; 这里面更上面不同的就是使用layer-list方式制作一个简单启动页面","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://chunyang1988.github.io/tags/Android/"}]},{"title":"炫酷终端","slug":"CoolShell","date":"2017-08-03T07:14:41.000Z","updated":"2017-08-06T03:08:02.000Z","comments":true,"path":"2017/08/03/CoolShell/","link":"","permalink":"https://chunyang1988.github.io/2017/08/03/CoolShell/","excerpt":"","text":"此文讲解的是通过oh_my_zsh来打造个性界面。建议Mac系统使用Iterm2 + oh_my_zsh进行打造炫酷终端。 Installation 安装根据需求进行如下操作，如在终端中可以直接输入 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 即可安装。 via curl 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; via wget 1sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装完成后，在用户目录有个隐藏文件夹.oh-my-zsh可以使用命令行查看 1cd ~/.oh-my-zsh Updates 升级默认情况下，系统会每隔几周检测升级，发现更新后提示用户进行更新。当然我们也可以关闭提示自动升级，还可以直接关闭自动升级功能。 开关提示升级DISABLE_UPDATE_PROMPT = true 开关自动升级DISABLE_AUTO_UPDATE = true 对~/.zshrc进行编辑。建议使用vi或者vim进行编辑更改。 手动升级在终端中输入upgrade_oh_my_zsh Edit Themes 更换主题所有主题都在~/.oh-my-zsh/themes目录中，想要预览可以看官网地址 更换主题以及操作升级开关，都是在~/.zshrc中进行编辑。 使用vi或者vim对~/.zshrc进行编辑 ZSH_THEME=&quot;robbyrussell&quot;等于号后面写上你要替换的主题名称即可。例如ZSH_THEME=&quot;af-magic&quot;。 Uninstall 卸载卸载oh_my_zsh只需要运行uninstall_oh_my_zsh即可。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://chunyang1988.github.io/categories/Tools/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://chunyang1988.github.io/tags/Shell/"}]},{"title":"搭建个人博客","slug":"Blog","date":"2017-08-01T08:46:50.000Z","updated":"2017-08-07T13:51:13.000Z","comments":true,"path":"2017/08/01/Blog/","link":"","permalink":"https://chunyang1988.github.io/2017/08/01/Blog/","excerpt":"","text":"此文讲解的搭建个人博客是通过GitHub Pages + Hexo进行搭建。 1.安装Hexo安装前需要需要确定是否安装Node.js以及Git，在此文我会重头一步一步安装操作。 a.安装 HomebrewHomebrew是 macOS 缺失的软件包管理器，具体哪些好处问什么要安装还是自行搜索吧。 安装只需要在终端中输入: 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装成功后，直接就可以使用brew进行安装Node以及Git了，当然可以安装的还有很多东西，就不列举了。 b.安装Node官网安装Node也可以，但是此文讲解的是通过brew进行安装，大家一起看看Homebrew的优点。 同样只需要在终端中输入: 1brew install node c.安装Git此处就不多说了直接上代码: 1brew install git d.安装Hexo至此准备工作都已经完成可以，开始安装Hex代码如下： 1npm install -g hexo-cli 2.建站初步环境都已经完成，剩下的就是建站了，运行一下命令即可完成建站操作。 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 并不一定非要按照上述代码去写，也可以这样写 1234mkdir &lt;folder&gt;cd &lt;folder&gt;hexo initnpm install 例如： 1234mkdir Blogscd Blogshexo init npm install 完成后目录结构如下 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 具体什么意思，这里面就不废话了，可以看官网 3.简单写作此处不会过度介绍，详情还是去看官网，在这里面只是简单介绍几种常用命令。 a.新建文章1hexo new [layout] &lt;title&gt; 其中[layout]有三种默认布局：post、page、draft，分别对应不同路径。 布局 路径 post source/_posts page source draft source/_drafts 例如： 1hexo new blogs b.更改主题使用maupassant主题为介绍 123git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassantnpm install hexo-renderer-jade@0.3.0 --savenpm install hexo-renderer-sass --save 将主题下载到指定目录，更改配置文件_config.ym里面的theme 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: maupassant 每个主题安装方式不一样，具体的说明看官网更加详细。 4.部署a.创建Github Pages这里面不多说，主要是创建一个yourName.github.io仓库 b.部署Hexo到Github这里面主要介绍使用hexo deploy部署到git上面 在配置文件_config.yml中配置deploy 1234deploy: type: git repo: git@github.com:yuserName/yuserName.github.io.git branch: master 例如： 1234deploy: type: git repo: git@github.com:Chunyang1988/chunyang1988.github.io.git branch: master 之后一件部署 1hexo deploy c.添加SSH密钥生成密钥 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 例如 1ssh-keygen -t rsa -C &quot;chunyang1988.cn@gmail.com&quot; 为了方便在后面提示信息中，直接按回车，一直回车下来。 d.部署部署前还需要安装 1npm install hexo-deployer-git --save 一般现在本地写好文章，运行 1hexo s 本地查看一下，如果可以，可以直接部署到git上面 1hexo d 结束这时候你输入自己的xxx.github.io即可查看自己的博客了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chunyang1988.github.io/tags/Hexo/"}]}]}